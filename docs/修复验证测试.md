# 节点名称提取修复验证

## 测试用例

### 测试 1: VMess 节点

**输入**:
```
vmess://eyJwcyI6IkhvbmcgS29uZy0wMSIsImFkZCI6ImhrLnRlc3QuY29tIiwicG9ydCI6NDQzLCJpZCI6InV1aWQtMTIzIn0=
```

**期望输出**: `Hong Kong-01`

**解释**: 从 VMess JSON 配置的 `ps` 字段提取

---

### 测试 2: VLESS 节点（无名称）

**输入**:
```
vless://uuid-123@sg.example.com:443?type=ws&path=/ws
```

**期望输出**: `sg.example.com`

**解释**: 从服务器地址提取

**修复前**: 返回空字符串（后端）或需要端口号（前端）  
**修复后**: 正确提取服务器地址

---

### 测试 3: VLESS 节点（带名称）

**输入**:
```
vless://uuid-123@sg.example.com:443?type=ws&path=/ws#Singapore-Fast
```

**期望输出**: `Singapore-Fast`

**解释**: 优先从 `#` 后提取

---

### 测试 4: Trojan 节点

**输入**:
```
trojan://password123@jp.test.com:443?sni=jp.test.com
```

**期望输出**: `jp.test.com`

**解释**: 从服务器地址提取

**修复前**: 返回空字符串（后端）  
**修复后**: 正确提取服务器地址

---

### 测试 5: Shadowsocks 节点（SIP002 格式）

**输入**:
```
ss://YWVzLTI1Ni1nY206cGFzc3dvcmRAc3MudGVzdC5jb206NDQz
```

解码后: `aes-256-gcm:password@ss.test.com:443`

**期望输出**: `ss.test.com`

---

### 测试 6: Shadowsocks 节点（带 @ 格式）

**输入**:
```
ss://YWVzLTI1Ni1nY206cGFzc3dvcmQ=@us.example.com:8388
```

**期望输出**: `us.example.com`

---

### 测试 7: Hysteria2 节点

**输入**:
```
hysteria2://hy2.example.com:443?auth=secret#HK-Hysteria2
```

**期望输出**: `HK-Hysteria2` (从 # 提取)

**修复前**: 不支持（后端和前端）  
**修复后**: 支持

---

### 测试 8: TUIC 节点

**输入**:
```
tuic://uuid:password@tuic.test.com:443?sni=tuic.test.com
```

**期望输出**: `tuic.test.com`

**修复前**: 不支持  
**修复后**: 支持

---

### 测试 9: Socks5 节点（无认证）

**输入**:
```
socks5://socks.proxy.com:1080
```

**期望输出**: `socks.proxy.com`

---

### 测试 10: Socks5 节点（有认证）

**输入**:
```
socks5://user:pass@socks.proxy.com:1080#My-Socks5
```

**期望输出**: `My-Socks5` (从 # 提取)

---

## 过滤规则测试

### 场景 1: 排除香港和日本节点

**过滤规则**: `香港|日本|HK|JP`

**节点列表**:
1. `vmess://... #香港-01` → ❌ 被过滤（匹配"香港"）
2. `vless://uuid@hk.example.com:443` → ✅ 保留（服务器地址 "hk.example.com" 不匹配）
3. `trojan://pass@jp.test.com:443` → ❌ 被过滤（服务器地址 "jp.test.com" 匹配 "JP"，不区分大小写）
4. `vless://uuid@sg.example.com:443#Singapore-01` → ✅ 保留
5. `ss://base64@us.proxy.com:443#美国节点` → ✅ 保留

**修复前**（后端）:
- 第 2、3 项因为名称提取失败（返回空），过滤行为不确定 ❌

**修复后**（前后端）:
- 所有节点都能正确提取名称并应用过滤规则 ✅

---

### 场景 2: 只保留新加坡节点（白名单）

**过滤规则**:
```
keep:Singapore|SG|新加坡
```

**节点列表**:
1. `vless://...@sg.example.com:443#Singapore-01` → ✅ 保留（名称匹配）
2. `vmess://... #新加坡-快速` → ✅ 保留（名称匹配）
3. `trojan://...@hk.test.com:443` → ❌ 被过滤（服务器地址不匹配）
4. `vless://...@singapore.proxy.net:443` → ✅ 保留（服务器地址匹配 "Singapore"）

---

## 手动测试步骤

### 前端测试

1. 打开浏览器控制台
2. 导航到应用页面
3. 执行测试脚本:

```javascript
// 测试链接数组
const testLinks = [
  {
    url: 'vmess://eyJwcyI6IkhvbmcgS29uZy0wMSIsImFkZCI6ImhrLnRlc3QuY29tIiwicG9ydCI6NDQzLCJpZCI6InV1aWQtMTIzIn0=',
    expected: 'Hong Kong-01'
  },
  {
    url: 'vless://uuid@sg.example.com:443?type=ws',
    expected: 'sg.example.com'
  },
  {
    url: 'trojan://password@jp.test.com:443',
    expected: 'jp.test.com'
  },
  {
    url: 'hysteria2://hy2.example.com:443?auth=secret#HK-Hysteria2',
    expected: 'HK-Hysteria2'
  },
  {
    url: 'tuic://uuid:password@tuic.test.com:443',
    expected: 'tuic.test.com'
  }
];

// 运行测试
import { subscriptionParser } from './lib/subscription-parser';

let passed = 0;
let failed = 0;

testLinks.forEach(({ url, expected }) => {
  const result = subscriptionParser.extractNodeNameFromUrl(url);
  const pass = result === expected;
  
  if (pass) {
    console.log(`✅ PASS: ${url.substring(0, 40)}...`);
    passed++;
  } else {
    console.error(`❌ FAIL: ${url.substring(0, 40)}...`);
    console.error(`   期望: "${expected}"`);
    console.error(`   实际: "${result}"`);
    failed++;
  }
});

console.log(`\n测试结果: ${passed} 通过, ${failed} 失败`);
```

### 后端测试

创建测试文件 `test-extract-name.js`:

```javascript
// 模拟后端的 extractName 方法
function extractName(link) {
  try {
    // 1. 优先从 # 后提取名称
    const hashIndex = link.lastIndexOf('#');
    if (hashIndex !== -1 && hashIndex < link.length - 1) {
      const name = decodeURIComponent(link.substring(hashIndex + 1));
      if (name.trim()) return name.trim();
    }

    // VMess
    if (link.startsWith('vmess://')) {
      const base64Part = link.substring(8);
      const config = JSON.parse(
        Buffer.from(base64Part, 'base64').toString('utf-8')
      );
      return config.ps || config.add || 'VMess';
    }

    // VLESS
    if (link.startsWith('vless://')) {
      const match = link.match(/vless:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Trojan
    if (link.startsWith('trojan://')) {
      const match = link.match(/trojan:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Shadowsocks
    if (link.startsWith('ss://')) {
      const atMatch = link.match(/@([^:?#]+)/);
      if (atMatch) return atMatch[1];

      const base64Match = link.match(/ss:\/\/([^#]+)/);
      if (base64Match) {
        const decoded = Buffer.from(base64Match[1], 'base64').toString();
        const serverMatch = decoded.match(/@([^:]+)/);
        if (serverMatch) return serverMatch[1];
      }
    }

    // Hysteria/Hysteria2
    if (link.match(/^(hysteria2?|hy2?):\/\//)) {
      const match = link.match(/^(?:hysteria2?|hy2?):\/\/([^:?#]+)/);
      if (match) return match[1];
    }

    // TUIC
    if (link.startsWith('tuic://')) {
      const match = link.match(/tuic:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Socks5
    if (link.startsWith('socks5://')) {
      const match = link.match(/socks5:\/\/(?:[^@]+@)?([^:?#]+)/);
      if (match) return match[1];
    }

    const protocolMatch = link.match(/^([^:]+):/);
    if (protocolMatch) {
      return protocolMatch[1].toUpperCase() + ' 节点';
    }
  } catch (e) {
    console.warn('extractName failed:', e);
  }
  
  return '未知节点';
}

// 测试用例
const tests = [
  {
    link: 'vmess://eyJwcyI6IkhvbmcgS29uZy0wMSIsImFkZCI6ImhrLnRlc3QuY29tIiwicG9ydCI6NDQzLCJpZCI6InV1aWQtMTIzIn0=',
    expected: 'Hong Kong-01'
  },
  {
    link: 'vless://uuid@sg.example.com:443?type=ws',
    expected: 'sg.example.com'
  },
  {
    link: 'trojan://password@jp.test.com:443',
    expected: 'jp.test.com'
  },
  {
    link: 'ss://YWVzLTI1Ni1nY206cGFzc3dvcmRAc3MudGVzdC5jb206NDQz',
    expected: 'ss.test.com'
  },
  {
    link: 'hysteria2://hy2.example.com:443?auth=secret#HK-Hysteria2',
    expected: 'HK-Hysteria2'
  },
  {
    link: 'tuic://uuid:password@tuic.test.com:443',
    expected: 'tuic.test.com'
  },
  {
    link: 'socks5://user:pass@socks.proxy.com:1080#My-Socks5',
    expected: 'My-Socks5'
  }
];

// 运行测试
let passed = 0;
let failed = 0;

tests.forEach(({ link, expected }) => {
  const result = extractName(link);
  const pass = result === expected;
  
  if (pass) {
    console.log(`✅ PASS: ${link.substring(0, 40)}...`);
    passed++;
  } else {
    console.error(`❌ FAIL: ${link.substring(0, 40)}...`);
    console.error(`   期望: "${expected}"`);
    console.error(`   实际: "${result}"`);
    failed++;
  }
});

console.log(`\n测试结果: ${passed} 通过, ${failed} 失败`);
```

运行:
```bash
node test-extract-name.js
```

---

## 集成测试

### 测试完整的过滤流程

1. 创建测试订阅，包含多种协议的节点
2. 添加过滤规则: `香港|HK`
3. 生成订阅链接并访问
4. 验证返回的节点列表不包含被过滤的节点

**测试脚本**:

```bash
# 1. 添加测试订阅到系统
# 2. 设置过滤规则
# 3. 生成链接
LINK="http://localhost:8788/your-token?target=base64"

# 4. 获取节点列表
curl "$LINK" | base64 -d > nodes.txt

# 5. 检查是否包含被过滤的节点
grep -i "香港\|HK" nodes.txt && echo "❌ 过滤失败" || echo "✅ 过滤成功"
```

---

## 验证清单

修复完成后，请验证以下项目：

- [ ] 后端 `extractName` 方法支持所有协议
- [ ] 前端 `extractNodeNameFromUrl` 方法支持所有协议
- [ ] 前后端提取相同节点链接返回相同的名称
- [ ] 过滤规则正确应用到所有类型的节点
- [ ] 订阅组链接生成时节点数量正确
- [ ] 节点预览显示正确的节点名称
- [ ] 没有引入新的 bug（回归测试）

---

## 修复总结

### 修复内容

1. **后端** (`functions/[[path]].ts`)
   - 增强 `extractName` 方法
   - 从仅支持 vmess 扩展到支持所有协议
   - 优先从 `#` 提取名称
   - 返回有意义的默认值（而非空字符串）

2. **前端** (`src/lib/subscription-parser.ts`)
   - 增强 `extractNodeNameFromUrl` 方法
   - 添加 hysteria、tuic、socks5 支持
   - 优先从 `#` 提取名称
   - 改进正则表达式匹配

### 影响范围

- ✅ **修复**: 过滤规则现在对所有协议都有效
- ✅ **改进**: 节点名称提取更准确
- ⚠️ **变化**: 之前依赖"空名称"行为的逻辑会改变

### 后续步骤

1. 运行上述测试确认修复有效
2. 检查现有的过滤规则是否需要调整
3. 更新文档说明支持的协议
4. 考虑添加自动化测试防止回归

---

**修复日期**: 2025-12-06  
**修复版本**: 当前版本  
**影响**: ⚠️ 中等（会改变现有过滤行为）
