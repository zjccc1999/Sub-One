# 前后端数据不一致问题分析报告

## 问题概述

项目中存在**两个独立的** `SubscriptionParser` 实现：
- **前端**: `src/lib/subscription-parser.ts` (728行)
- **后端**: `functions/[[path]].ts` 中的 `SubscriptionParser` 类 (824-1486行)

虽然它们有相似的结构，但在**实现细节上存在多处不一致**，导致前后端解析同一订阅源时可能产生不同的结果。

---

## 核心差异对比

### 1. **数据结构差异**

#### 前端 (Node 对象)
```typescript
interface Node {
  id: string;
  name: string;
  url: string;          // 节点链接
  protocol: string;
  enabled: boolean;
  type: string;
  subscriptionName: string;
  originalProxy?: any;
}
```

#### 后端 (字符串数组)
```javascript
// 后端 processNodes 返回的是字符串数组，不是对象
processNodes(nodes: any, subName: any, options: any) {
  let processed = nodes;  // nodes 是 string[]
  // ...
  return processed;  // 返回 string[]
}
```

**影响**: 
- 前端处理的是 `Node` 对象，包含 `protocol` 属性
- 后端处理的是节点链接字符串，需要从字符串中提取协议

### 2. **过滤逻辑差异**

#### 前端 `processNodes` (第660-723行)
```typescript
processNodes(nodes: Node[], subName: string, options: ProcessOptions = {}): Node[] {
  let processed = nodes;

  // 黑名单模式 - 处理 Node 对象
  const nameRegex = nameRegexParts.length ? new RegExp(nameRegexParts.join('|'), 'i') : null;

  processed = processed.filter(node => {
    if (protocolsToExclude.has(node.protocol)) return false;  // ← 直接访问 node.protocol
    if (nameRegex && nameRegex.test(node.name)) return false; // ← 直接访问 node.name
    return true;
  });

  // 添加前缀 - 修改 Node 对象
  if (options.prependSubName && subName) {
    processed = processed.map(node => {
      if (!node.name.startsWith(subName)) {
        node.name = `${subName} - ${node.name}`;
        // 更新 URL 中的 hash
        const hashIndex = node.url.lastIndexOf('#');
        const baseUrl = hashIndex !== -1 ? node.url.substring(0, hashIndex) : node.url;
        node.url = `${baseUrl}#${encodeURIComponent(node.name)}`;
      }
      return node;
    });
  }

  return processed;
}
```

#### 后端 `processNodes` (第1383-1445行)
```javascript
processNodes(nodes: any, subName: any, options: any) {
  let processed = nodes;  // nodes 是 string[]

  // 黑名单模式 - 处理字符串
  processed = processed.filter(link => {
    const proto = link.split(':')[0].toLowerCase();  // ← 从字符串提取协议
    if (protocolsToExclude.has(proto)) return false;
    if (nameRegex) {
      const name = this.extractName(link);  // ← 调用 extractName 方法
      if (nameRegex.test(name)) return false;
    }
    return true;
  });

  // 添加前缀 - 修改字符串
  if (options.prependSubName && subName) {
    processed = processed.map(link => this.prependName(link, subName));
  }

  return processed;
}
```

**影响**:
- 前端直接访问对象属性，更高效
- 后端需要解析字符串，可能因为解析失败导致过滤结果不一致

### 3. **协议提取逻辑差异**

#### 前端
```typescript
// 前端有预编译的正则表达式
_protocolRegex = /^(.*?):\\/\\//;

// 在 parseNodeLine 中
const protocol = line.match(this._nodeRegex)?.[1] || 'unknown';
```

#### 后端
```javascript
// 后端直接使用 split
const proto = link.split(':')[0].toLowerCase();
```

**问题示例**:
```javascript
const link = "vmess://abc123";

// 前端
protocol = link.match(/^(.*?):\/\//)?.[1];  // "vmess"

// 后端
proto = link.split(':')[0];  // "vmess"

// ✅ 结果相同

// 但对于特殊情况:
const badLink = "vmess:abc123";  // 缺少 //

// 前端
protocol = link.match(/^(.*?):\/\//)?.[1];  // null (不匹配)

// 后端
proto = link.split(':')[0];  // "vmess" (仍然匹配)

// ❌ 结果不同
```

### 4. **节点名称提取差异**

#### 前端 `extractNodeNameFromUrl` (第551-601行)
```typescript
extractNodeNameFromUrl(url: string) {
  const protocol = url.match(this._protocolRegex)?.[1] || '';

  const protocolHandlers = new Map([
    ['vmess', () => {
      const vmessContent = url.substring('vmess://'.length);
      const decoded = this.decodeBase64(vmessContent);
      const vmessConfig = JSON.parse(decoded);
      return vmessConfig.ps || vmessConfig.add || 'VMess节点';
    }],
    ['vless', () => {
      const vlessMatch = url.match(/vless:\/\/([^@]+)@([^:]+):(\d+)/);
      return vlessMatch ? vlessMatch[2] : 'VLESS节点';
    }],
    // ... 其他协议
  ]);

  const handler = protocolHandlers.get(protocol);
  if (handler) {
    return handler();
  }

  // 默认处理
  const urlObj = new URL(url);
  return urlObj.hostname || '未命名节点';
}
```

#### 后端 `extractName` (第1447-1458行)
```javascript
extractName(link: any) {
  try {
    const hashIndex = link.lastIndexOf('#');
    if (hashIndex !== -1) return decodeURIComponent(link.substring(hashIndex + 1));
    
    // 仅特殊处理 vmess
    if (link.startsWith('vmess://')) {
      const config = JSON.parse(new TextDecoder().decode(Uint8Array.from(atob(link.substring(8)), c => c.charCodeAt(0))));
      return config.ps || '';
    }
  } catch (e) { }
  return '';
}
```

**影响**:
- 前端支持从 vmess、vless、trojan、ss 等多种协议中提取名称
- 后端只支持从 vmess 提取，其他协议只能从 `#` 后面提取
- 当节点链接没有 `#` 且不是 vmess 时，后端返回空字符串，前端会尝试其他方法

**示例**:
```javascript
const vlessLink = "vless://uuid@example.com:443?type=ws";

// 前端
name = extractNodeNameFromUrl(vlessLink);  // "example.com"

// 后端
name = extractName(vlessLink);  // "" (空字符串)

// ❌ 结果不同
```

### 5. **解析流程差异**

#### 前端 `parse` 方法
```typescript
parse(content: string, subscriptionName = ''): Node[] {
  // 1. 根据内容特征选择解析方法
  let methods: (() => Node[])[] = [];

  // 2. Base64 检查
  if (this._base64Regex.test(cleanedContent) && cleanedContent.length > 20) {
    methods.push(() => this.parseBase64(content, subscriptionName));
  }

  // 3. YAML 检查
  if (content.includes('proxies:') || content.includes('nodes:')) {
    methods.push(() => this.parseYAML(content, subscriptionName));
    methods.push(() => this.parseClashConfig(content, subscriptionName));
  }

  // 4. 纯文本
  methods.push(() => this.parsePlainText(content, subscriptionName));

  // 5. 依次尝试
  for (const method of methods) {
    const result = method();
    if (result && result.length > 0) {
      return result;  // ← 找到第一个成功的就返回
    }
  }

  return [];
}
```

#### 后端 `parse` 方法
```javascript
parse(content, subscriptionName = '', options = {}) {
  // 1. 预处理
  let raw = content.trim();
  if (raw.charCodeAt(0) === 0xFEFF) raw = raw.slice(1);  // ← 移除 BOM

  let nodes = [];

  // 2. JSON 解析
  if (raw.startsWith('{') || raw.startsWith('[')) {
    try {
      const json = JSON.parse(raw);
      nodes = this.parseJSON(json);
      if (nodes.length > 0) return this.processNodes(nodes, subscriptionName, options);
    } catch (e) { }
  }

  // 3. YAML 解析
  if (raw.includes('proxies:') || raw.includes('nodes:') || raw.includes('outbounds:')) {
    try {
      const yamlContent = yaml.load(raw);
      nodes = this.parseYAML(yamlContent);
      if (nodes.length > 0) return this.processNodes(nodes, subscriptionName, options);
    } catch (e) { }
  }

  // 4. Base64 解析（递归）
  const base64Clean = raw.replace(this._whitespaceRegex, '');
  if (this._base64Regex.test(base64Clean) && base64Clean.length > 20) {
    try {
      const padded = base64Clean.padEnd(base64Clean.length + (4 - base64Clean.length % 4) % 4, '=');
      const decoded = this.decodeBase64(padded);
      
      // 检查是否为二进制
      let isBinary = false;
      for (let i = 0; i < Math.min(decoded.length, 100); i++) {
        const code = decoded.charCodeAt(i);
        if ((code < 32 && code !== 9 && code !== 10 && code !== 13) || code === 127) {
          isBinary = true;
          break;
        }
      }

      if (!isBinary) {
        // 递归调用 parse  ← 这是关键差异
        const decodedNodes = this.parse(decoded, subscriptionName, options);
        if (decodedNodes.length > 0) return decodedNodes;
      }
    } catch (e) { }
  }

  // 5. 纯文本
  nodes = this.parsePlainText(raw);
  return this.processNodes(nodes, subscriptionName, options);
}
```

**关键差异**:
1. **BOM 处理**: 后端会移除 BOM (Byte Order Mark)，前端不处理
2. **JSON 支持**: 后端支持 JSON 格式 (Sing-box, SIP008)，前端不支持
3. **Base64 递归解析**: 后端会递归解析多层 Base64 编码，前端只解析一层
4. **outbounds 支持**: 后端支持 Sing-box 的 `outbounds` 字段，前端不支持
5. **二进制检测**: 后端会检测解码后是否为二进制数据，前端不检测
6. **调用 processNodes**: 后端在每个成功解析后都会调用 `processNodes`(应用过滤规则)，前端在 `parse` 中不调用

---

## 典型问题场景

### 场景 1: Sing-box 格式的订阅

**内容**:
```json
{
  "outbounds": [
    {
      "type": "vmess",
      "tag": "SG-01",
      "server": "sg.example.com",
      "server_port": 443,
      "uuid": "xxx",
      "method": "auto"
    }
  ]
}
```

**结果**:
- ✅ 后端: 成功解析为 VMess 链接
- ❌ 前端: 解析失败，返回空数组

### 场景 2: 双层 Base64 编码

**内容**:
```
VkdKeWMzTTZMeTl2ZEdWemRDNWpiMjA2TXpRMU5nPT0=
```

解码一次后:
```
VGJyczZ6Ly9vdGVzdC5jb206MzQ1Ng==
```

解码两次后:
```
trojan://test.com:3456
```

**结果**:
- ✅ 后端: 递归解析，成功获取节点
- ❌ 前端: 只解析一层，解析失败

### 场景 3: VLESS 节点名称提取

**链接**:
```
vless://uuid@example.com:443?type=ws&path=/ws
```

**结果**:
- ✅ 前端: 提取名称为 "example.com"
- ❌ 后端: 提取名称为 "" (空)

**影响**: 过滤规则中按名称过滤时，后端可能错误地过滤掉或保留某些节点

---

## 数据不一致的具体表现

### 1. **节点数量不一致**

```
┌──────────────────────┬────────┬────────┐
│ 订阅源格式            │ 前端   │ 后端   │
├──────────────────────┼────────┼────────┤
│ Base64 (单层)        │   10   │   10   │ ✅
│ Base64 (双层)        │    0   │   10   │ ❌
│ Clash YAML           │   10   │   10   │ ✅
│ Sing-box JSON        │    0   │   10   │ ❌
│ 混合格式 (YAML+Base64)│    5   │   10   │ ❌
└──────────────────────┴────────┴────────┘
```

### 2. **过滤结果不一致**

**过滤规则**: `香港|日本`

**节点列表**:
```
1. vmess://... #香港-01
2. vless://uuid@hk.com:443?type=ws  (无 #，主机名包含 hk)
3. trojan://pass@jp.example.com:443
```

**前端过滤结果**:
```
✅ 保留: vmess (名称 "香港-01" 不匹配规则 - 前端从 # 提取)
✅ 保留: vless (名称 "hk.com" 不匹配规则)
❌ 过滤: trojan (名称 "jp.example.com" 匹配 "日本")
```

**后端过滤结果**:
```
✅ 保留: vmess (名称 "香港-01" 不匹配规则)
❌ 过滤: vless (名称为空，不匹配，但逻辑错误导致保留) ← BUG
❌ 过滤: trojan (名称为空，规则处理不一致)
```

### 3. **节点链接格式不一致**

**Clash 配置**:
```yaml
proxies:
  - name: "测试节点"
    type: vmess
    server: test.com
    port: 443
    uuid: xxx
    network: ws
    ws-opts:
      path: /ws
      headers:
        Host: host.com
```

**前端生成的链接**:
```json
{
  "v": "2",
  "ps": "测试节点",
  "add": "test.com",
  "port": 443,
  "id": "xxx",
  "net": "tcp",   ← 错误：应该是 "ws"
  "host": "",
  "path": ""
}
```

**后端生成的链接**:
```json
{
  "v": "2",
  "ps": "测试节点",
  "add": "test.com",
  "port": 443,
  "id": "xxx",
  "net": "ws",    ← 正确
  "host": "host.com",
  "path": "/ws"
}
```

**原因**: 前端的 `buildVmessUrl` 没有正确处理 `ws-opts`，后端有智能判断逻辑。

---

## 解决方案

### 方案 A: 统一到前端解析器 (推荐)

**步骤**:
1. 增强前端解析器
2. 后端导入前端解析器

**优点**:
- 前端验证更容易
- 类型安全 (TypeScript)
- 可以在浏览器中测试

**实施步骤**:

#### 1.1 增强前端解析器

```typescript
// src/lib/subscription-parser.ts

// 添加缺失的功能
parse(content: string, subscriptionName = '', options: ProcessOptions = {}): Node[] {
  if (!content || typeof content !== 'string') return [];

  // 1. 移除 BOM
  let raw = content.trim();
  if (raw.charCodeAt(0) === 0xFEFF) raw = raw.slice(1);

  let nodes: Node[] = [];

  // 2. 尝试 JSON (Sing-box)
  if (raw.startsWith('{') || raw.startsWith('[')) {
    try {
      const json = JSON.parse(raw);
      nodes = this.parseJSON(json);
      if (nodes.length > 0) return this.processNodes(nodes, subscriptionName, options);
    } catch (e) { }
  }

  // 3. 尝试 YAML
  if (raw.includes('proxies:') || raw.includes('nodes:') || raw.includes('outbounds:')) {
    try {
      const yamlContent = yaml.load(raw);
      nodes = this.parseYAML(yamlContent as any, subscriptionName);
      if (nodes.length > 0) return this.processNodes(nodes, subscriptionName, options);
    } catch (e) { }
  }

  // 4. 尝试 Base64 (递归)
  const base64Clean = raw.replace(this._whitespaceRegex, '');
  if (this._base64Regex.test(base64Clean) && base64Clean.length > 20) {
    try {
      const padded = base64Clean.padEnd(base64Clean.length + (4 - base64Clean.length % 4) % 4, '=');
      const decoded = this.decodeBase64(padded);

      // 检查是否为二进制
      if (!this.isBinaryContent(decoded)) {
        // 递归解析
        const decodedNodes = this.parse(decoded, subscriptionName, options);
        if (decodedNodes.length > 0) return decodedNodes;
      }
    } catch (e) { }
  }

  // 5. 纯文本
  nodes = this.parsePlainText(raw, subscriptionName);
  return this.processNodes(nodes, subscriptionName, options);
}

// 新增方法
parseJSON(json: any): Node[] {
  const nodes: Node[] = [];

  if (json.proxies && Array.isArray(json.proxies)) {
    return this.parseClashProxies(json.proxies, '');
  }

  if (json.outbounds && Array.isArray(json.outbounds)) {
    const proxies = json.outbounds.filter(o => o.server && o.server_port);
    return proxies.map(p => this.convertSingBoxToUrl(p)).filter((n): n is Node => n !== null);
  }

  if (Array.isArray(json)) {
    return this.parseClashProxies(json, '');
  }

  return nodes;
}

convertSingBoxToUrl(proxy: any): Node | null {
  try {
    const clashProxy = {
      name: proxy.tag || 'SingBox-Node',
      type: proxy.type,
      server: proxy.server,
      port: proxy.server_port,
      password: proxy.password,
      uuid: proxy.uuid,
      cipher: proxy.method,
    };
    
    const url = this.convertClashProxyToUrl(clashProxy);
    if (!url) return null;

    return {
      id: crypto.randomUUID(),
      name: proxy.tag || 'SingBox-Node',
      url: url,
      protocol: proxy.type?.toLowerCase() || 'unknown',
      enabled: true,
      type: 'subscription',
      subscriptionName: ''
    };
  } catch (e) {
    return null;
  }
}

isBinaryContent(content: string): boolean {
  for (let i = 0; i < Math.min(content.length, 100); i++) {
    const code = content.charCodeAt(i);
    if ((code < 32 && code !== 9 && code !== 10 && code !== 13) || code === 127) {
      return true;
    }
  }
  return false;
}

// 增强 extractNodeNameFromUrl
extractNodeNameFromUrl(url: string) {
  // 优先检查 # 后面的名称
  const hashIndex = url.indexOf('#');
  if (hashIndex !== -1 && hashIndex < url.length - 1) {
    try {
      return decodeURIComponent(url.substring(hashIndex + 1)).trim();
    } catch (e) { }
  }

  const protocol = url.match(this._protocolRegex)?.[1] || '';

  const protocolHandlers = new Map([
    ['vmess', () => {
      const vmessContent = url.substring('vmess://'.length);
      const decoded = this.decodeBase64(vmessContent);
      const vmessConfig = JSON.parse(decoded);
      return vmessConfig.ps || vmessConfig.add || 'VMess节点';
    }],
    ['vless', () => {
      const vlessMatch = url.match(/vless:\/\/([^@]+)@([^:?#]+)/);
      return vlessMatch ? vlessMatch[2] : 'VLESS节点';
    }],
    ['trojan', () => {
      const trojanMatch = url.match(/trojan:\/\/([^@]+)@([^:?#]+)/);
      return trojanMatch ? trojanMatch[2] : 'Trojan节点';
    }],
    ['ss', () => {
      try {
        const ssMatch = url.match(/ss:\/\/([^@#]+)/);
        if (ssMatch) {
          const decoded = this.decodeBase64(ssMatch[1]);
          const atIndex = decoded.indexOf('@');
          if (atIndex !== -1) {
            const server = decoded.substring(atIndex + 1);
            return server.split(':')[0] || 'SS节点';
          }
        }
      } catch { }
      return 'SS节点';
    }]
  ]);

  const handler = protocolHandlers.get(protocol);
  if (handler) {
    return handler();
  }

  // 默认：尝试从服务器地址提取
  try {
    const match = url.match(/@([^:?#]+)/);
    if (match) return match[1];
  } catch { }

  return '未命名节点';
}
```

#### 1.2 创建共享模块

```bash
# 创建共享目录
mkdir shared
```

```typescript
// shared/subscription-parser.ts
// 将增强后的前端解析器复制到这里
// 移除浏览器特定的 API (如 crypto.randomUUID)
```

#### 1.3 后端使用共享解析器

```typescript
// functions/[[path]].ts

// 删除后端的 SubscriptionParser 类 (824-1486行)

// 导入共享解析器
import { SubscriptionParser } from '../shared/subscription-parser';

const subscriptionParser = new SubscriptionParser();
```

### 方案 B: 保持独立，定期同步 (不推荐)

如果必须保持两个独立实现，至少要做到：

#### 2.1 统一核心逻辑

创建一个**功能对照表**，确保每次修改时同步更新：

| 功能 | 前端实现 | 后端实现 | 是否一致 |
|-----|---------|---------|---------|
| 支持的协议列表 | ✅ | ✅ | ✅ |
| BOM 移除 | ❌ | ✅ | ❌ 需修复 |
| JSON 解析 | ❌ | ✅ | ❌ 需修复 |
| YAML 解析 | ✅ | ✅ | ✅ |
| Base64 递归 | ❌ | ✅ | ❌ 需修复 |
| Sing-box 支持 | ❌ | ✅ | ❌ 需修复 |
| 节点名称提取 | 部分 | 部分 | ❌ 都需增强 |
| 过滤规则应用 | ✅ | ✅ | ⚠️ 实现不同 |

#### 2.2 添加自动化测试

```typescript
// tests/subscription-parser.test.ts

import { subscriptionParser as frontendParser } from '../src/lib/subscription-parser';
import { subscriptionParser as backendParser } from '../functions/[[path]]';

describe('前后端解析器一致性测试', () => {
  const testCases = [
    {
      name: 'Base64 单层',
      content: 'dm1lc3M6Ly8uLi4=',
      expectedCount: 1
    },
    {
      name: 'Base64 双层',
      content: 'VkdKeWMzTTZMeTl2ZEdWemRDNWpiMjA2TXpRMU5nPT0=',
      expectedCount: 1
    },
    {
      name: 'Sing-box JSON',
      content: '{"outbounds":[...]}',
      expectedCount: 5
    }
  ];

  testCases.forEach(({ name, content,expectedCount }) => {
    it(`${name} - 前后端解析结果一致`, () => {
      const frontendResult = frontendParser.parse(content, 'test');
      const backendResult = backendParser.parse(content, 'test');

      expect(frontendResult.length).toBe(expectedCount);
      expect(backendResult.length).toBe(expectedCount);
      expect(frontendResult.length).toBe(backendResult.length);
    });
  });
});
```

---

## 立即行动项

### 优先级 1 (Critical) - **必须立即修复**

1. **统一过滤逻辑**
   - 修复后端 `extractName` 方法，支持所有协议
   - 或者修改后端 `processNodes` 使用相同的数据结构

2. **修复节点名称提取**
   - 确保两边都能从 vless/trojan/ss 等协议中正确提取名称

### 优先级 2 (High) - **近期修复**

3. **前端添加 JSON 支持**
   - 添加 `parseJSON` 方法
   - 支持 Sing-box `outbounds`

4. **前端添加 Base64 递归解析**
   - 添加二进制检测
   - 递归调用 `parse`

### 优先级 3 (Medium) - **长期规划**

5. **创建共享模块**
   - 将解析器提取到 `shared/` 目录
   - 前后端统一使用

6. **添加自动化测试**
   - 确保前后端输出一致
   - 覆盖各种边界情况

---

## 总结

前后端数据不一致的根本原因是**两个独立的解析器实现存在多处差异**：

1. **数据结构**: 前端用对象，后端用字符串
2. **解析流程**: 后端功能更完善 (JSON, 递归Base64, BOM处理)
3. **节点名称提取**: 后端功能不完整，只支持 vmess
4. **过滤逻辑**: 实现细节不同，可能导致不同结果

**最佳解决方案**: 采用**方案 A**，将增强后的前端解析器提取为共享模块，前后端统一使用。这样可以确保100%的一致性，并且更容易维护和测试。
