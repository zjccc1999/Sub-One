# 前后端数据不一致 - 快速修复补丁

## 🚨 紧急修复：后端节点名称提取

当前后端的 `extractName` 方法只支持 vmess 和 `#` 后的名称，导致其他协议（vless、trojan、ss等）的节点名称无法正确提取，进而影响过滤规则的应用。

### 问题代码 (functions/[[path]].ts 第1447-1458行)

```javascript
// ❌ 当前实现 - 功能不完整
extractName(link: any) {
  try {
    const hashIndex = link.lastIndexOf('#');
    if (hashIndex !== -1) return decodeURIComponent(link.substring(hashIndex + 1));
    
    // 仅特殊处理 vmess
    if (link.startsWith('vmess://')) {
      const config = JSON.parse(new TextDecoder().decode(Uint8Array.from(atob(link.substring(8)), c => c.charCodeAt(0))));
      return config.ps || '';
    }
  } catch (e) { }
  return '';  // ← 其他协议都返回空字符串！
}
```

### 修复后的代码

```javascript
// ✅ 增强版 - 支持所有协议
extractName(link: any) {
  try {
    // 1. 优先从 # 后提取名称
    const hashIndex = link.lastIndexOf('#');
    if (hashIndex !== -1 && hashIndex < link.length - 1) {
      const name = decodeURIComponent(link.substring(hashIndex + 1));
      if (name.trim()) return name.trim();
    }

    // 2. 根据协议特殊处理
    // VMess: 从 JSON 配置中提取
    if (link.startsWith('vmess://')) {
      const base64Part = link.substring(8);
      const config = JSON.parse(
        new TextDecoder().decode(
          Uint8Array.from(atob(base64Part), c => c.charCodeAt(0))
        )
      );
      return config.ps || config.add || 'VMess';
    }

    // VLESS: vless://uuid@server:port
    if (link.startsWith('vless://')) {
      const match = link.match(/vless:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Trojan: trojan://password@server:port
    if (link.startsWith('trojan://')) {
      const match = link.match(/trojan:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Shadowsocks: ss://base64(method:password)@server:port
    if (link.startsWith('ss://')) {
      try {
        // 尝试提取 @server 部分
        const atMatch = link.match(/@([^:?#]+)/);
        if (atMatch) return atMatch[1];

        // 如果没有 @，可能是 SIP002 格式，需要解码
        const base64Match = link.match(/ss:\/\/([^#]+)/);
        if (base64Match) {
          const decoded = atob(base64Match[1]);
          const serverMatch = decoded.match(/@([^:]+)/);
          if (serverMatch) return serverMatch[1];
        }
      } catch (e) {
        // Base64 解码失败，降级到默认
      }
    }

    // Hysteria/Hysteria2: hysteria(2)://server:port 或 hy(2)://server:port
    if (link.match(/^(hysteria2?|hy2?):\/\//)) {
      const match = link.match(/^(?:hysteria2?|hy2?):\/\/([^:?#]+)/);
      if (match) return match[1];
    }

    // TUIC: tuic://uuid:password@server:port
    if (link.startsWith('tuic://')) {
      const match = link.match(/tuic:\/\/[^@]+@([^:?#]+)/);
      if (match) return match[1];
    }

    // Socks5: socks5://[user:pass@]server:port
    if (link.startsWith('socks5://')) {
      const match = link.match(/socks5:\/\/(?:[^@]+@)?([^:?#]+)/);
      if (match) return match[1];
    }

    // 3. 默认：返回协议名作为标识
    const protocolMatch = link.match(/^([^:]+):/);
    if (protocolMatch) {
      return protocolMatch[1].toUpperCase() + ' 节点';
    }

  } catch (e) {
    console.warn('extractName failed for link:', link, e);
  }
  
  return '未知节点';  // ← 改为有意义的默认值
}
```

## 应用修复

### 方法 1: 手动替换

1. 打开 `functions/[[path]].ts`
2. 定位到第 1447 行的 `extractName` 方法
3. 用上面的增强版代码替换整个方法
4. 保存文件

### 方法 2: 使用 Git Patch

```bash
cd c:\Users\Administrator\Desktop\Sub-One

# 创建补丁文件
cat > extractName.patch << 'EOF'
--- a/functions/[[path]].ts
+++ b/functions/[[path]].ts
@@ -1446,13 +1446,79 @@
 
     extractName(link: any) {
         try {
+            // 1. 优先从 # 后提取名称
             const hashIndex = link.lastIndexOf('#');
-            if (hashIndex !== -1) return decodeURIComponent(link.substring(hashIndex + 1));
-            // 特殊处理 vmess
+            if (hashIndex !== -1 && hashIndex < link.length - 1) {
+                const name = decodeURIComponent(link.substring(hashIndex + 1));
+                if (name.trim()) return name.trim();
+            }
+
+            // 2. 根据协议特殊处理
+            // VMess: 从 JSON 配置中提取
             if (link.startsWith('vmess://')) {
-                const config = JSON.parse(new TextDecoder().decode(Uint8Array.from(atob(link.substring(8)), c => c.charCodeAt(0))));
-                return config.ps || '';
+                const base64Part = link.substring(8);
+                const config = JSON.parse(
+                    new TextDecoder().decode(
+                        Uint8Array.from(atob(base64Part), c => c.charCodeAt(0))
+                    )
+                );
+                return config.ps || config.add || 'VMess';
             }
-        } catch (e) { }
-        return '';
+
+            // VLESS
+            if (link.startsWith('vless://')) {
+                const match = link.match(/vless:\/\/[^@]+@([^:?#]+)/);
+                if (match) return match[1];
+            }
+
+            // Trojan
+            if (link.startsWith('trojan://')) {
+                const match = link.match(/trojan:\/\/[^@]+@([^:?#]+)/);
+                if (match) return match[1];
+            }
+
+            // Shadowsocks
+            if (link.startsWith('ss://')) {
+                try {
+                    const atMatch = link.match(/@([^:?#]+)/);
+                    if (atMatch) return atMatch[1];
+
+                    const base64Match = link.match(/ss:\/\/([^#]+)/);
+                    if (base64Match) {
+                        const decoded = atob(base64Match[1]);
+                        const serverMatch = decoded.match(/@([^:]+)/);
+                        if (serverMatch) return serverMatch[1];
+                    }
+                } catch (e) { }
+            }
+
+            // Hysteria/Hysteria2
+            if (link.match(/^(hysteria2?|hy2?):\/\//)) {
+                const match = link.match(/^(?:hysteria2?|hy2?):\/\/([^:?#]+)/);
+                if (match) return match[1];
+            }
+
+            // TUIC
+            if (link.startsWith('tuic://')) {
+                const match = link.match(/tuic:\/\/[^@]+@([^:?#]+)/);
+                if (match) return match[1];
+            }
+
+            // Socks5
+            if (link.startsWith('socks5://')) {
+                const match = link.match(/socks5:\/\/(?:[^@]+@)?([^:?#]+)/);
+                if (match) return match[1];
+            }
+
+            // 3. 默认：返回协议名
+            const protocolMatch = link.match(/^([^:]+):/);
+            if (protocolMatch) {
+                return protocolMatch[1].toUpperCase() + ' 节点';
+            }
+
+        } catch (e) {
+            console.warn('extractName failed for link:', link, e);
+        }
+        
+        return '未知节点';
     }
EOF

# 应用补丁
git apply extractName.patch
```

## 验证修复

### 测试脚本

在浏览器控制台或 Node.js 中运行：

```javascript
// 测试用例
const testLinks = [
  {
    link: 'vmess://eyJwcyI6IkhLLTAxIiwiYWRkIjoiaGsudGVzdC5jb20iLCJwb3J0Ijo0NDMsImlkIjoieHh4In0=',
    expected: 'HK-01'
  },
  {
    link: 'vless://uuid@sg.example.com:443?type=ws',
    expected: 'sg.example.com'
  },
  {
    link: 'trojan://password@jp.test.com:443',
    expected: 'jp.test.com'
  },
  {
    link: 'ss://YWVzLTI1Ni1nY206cGFzc3dvcmRAc3MudGVzdC5jb206NDQz',
    expected: 'ss.test.com'
  },
  {
    link: 'hysteria2://hy2.example.com:443?auth=xxx',
    expected: 'hy2.example.com'
  }
];

// 假设你的 extractName 函数已经定义
testLinks.forEach(({ link, expected }) => {
  const result = extractName(link);
  const pass = result === expected;
  console.log(`${pass ? '✅' : '❌'} ${link.substring(0, 30)}...`);
  console.log(`   期望: "${expected}", 实际: "${result}"`);
});
```

### 预期输出

```
✅ vmess://eyJwcyI6IkhLLTAxIiwiY...
   期望: "HK-01", 实际: "HK-01"
✅ vless://uuid@sg.example.com:44...
   期望: "sg.example.com", 实际: "sg.example.com"
✅ trojan://password@jp.test.com...
   期望: "jp.test.com", 实际: "jp.test.com"
✅ ss://YWVzLTI1Ni1nY206cGFzc3dvc...
   期望: "ss.test.com", 实际: "ss.test.com"
✅ hysteria2://hy2.example.com:4...
   期望: "hy2.example.com", 实际: "hy2.example.com"
```

## 影响范围

修复后的影响：

### ✅ 修复的问题

1. **过滤规则现在正确工作**
   - 之前：VLESS/Trojan 节点因为名称为空，过滤规则无效
   - 现在：所有协议的节点都能正确提取名称，过滤规则生效

2. **订阅组链接生成更准确**
   - 之前：无名称节点可能被错误保留或过滤
   - 现在：按实际服务器地址过滤

3. **前端预览显示正确**
   - 之前：某些节点显示为空名称
   - 现在：所有节点都有有意义的名称

### ⚠️ 可能的副作用

1. **过滤结果变化**
   - 如果你之前的过滤规则依赖于"空名称"的特性，修复后行为会改变
   - 建议：重新检查过滤规则

2. **节点数量变化**
   - 如果之前因为名称提取失败导致某些节点被误过滤，修复后这些节点会出现
   - 建议：更新后检查节点列表

## 部署步骤

### 1. 备份当前文件

```bash
cp functions/[[path]].ts functions/[[path]].ts.backup
```

### 2. 应用修复

手动替换或使用 Git patch（见上文）

### 3. 测试

```bash
# 本地测试
npm run dev

# 访问订阅链接，检查节点列表
curl "http://localhost:8788/your-token/profile-id?target=base64" | base64 -d
```

### 4. 部署到生产环境

```bash
# 如果使用 Cloudflare Pages
npm run deploy

# 或者直接推送到 Git（如果已配置自动部署）
git add functions/[[path]].ts
git commit -m "fix: 增强 extractName 方法，支持所有协议的节点名称提取"
git push
```

## 后续建议

这个补丁只是**紧急修复**，解决了最严重的问题。完整的解决方案仍需要：

1. ✅ **立即**: 应用此补丁（已完成）
2. 🔜 **本周内**: 同步前端的 `extractNodeNameFromUrl` 方法，确保一致性
3. 📅 **下个迭代**: 实施"方案 A" - 创建共享解析器模块
4. 🧪 **持续**: 添加自动化测试，防止回归

---

**更新时间**: 2025-12-06  
**适用版本**: 当前版本  
**优先级**: 🔴 Critical  
**预计影响**: ⚠️ 中等（会改变现有过滤行为）
