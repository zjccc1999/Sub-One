# 订阅系统架构分析

## 📋 目录

1. [核心概念](#核心概念)
2. [数据流向](#数据流向)
3. [节点信息的多个"来源"](#节点信息的多个来源)
4. [链接生成流程](#链接生成流程)
5. [常见问题和混淆点](#常见问题和混淆点)
6. [建议的改进方向](#建议的改进方向)

---

## 核心概念

### 1. **订阅 (Subscription)**
**定义位置**: `src/types.ts`

```typescript
export interface Subscription {
    id: string;
    name?: string;
    url?: string;           // 订阅源URL（HTTP链接）或手动节点链接
    enabled: boolean;
    nodeCount?: number;     // 节点数量（从订阅源获取）
    isUpdating?: boolean;
    userInfo?: any;         // 用户流量信息
    exclude?: string;       // 排除规则（过滤节点）
}
```

**功能**:
- **存储订阅源信息**：可以是HTTP订阅链接，也可以是手动添加的单个节点
- **节点计数**：`nodeCount` 表示该订阅源包含多少个节点
- **过滤规则**：`exclude` 字段用于过滤不需要的节点

**存储位置**: 
- 前端：`App.vue` 中的 `subs` ref
- 后端：Cloudflare KV 存储，键名为 `KV_KEY_SUBS` (sub_one_subscriptions_v1)

---

### 2. **订阅组 (Profile)**
**定义位置**: `src/types.ts`

```typescript
export interface Profile {
    id: string;
    name: string;
    enabled: boolean;
    subscriptions: string[];    // 包含的订阅ID列表
    manualNodes: string[];      // 手动节点链接列表
    customId?: string;          // 自定义分享ID
    subConverter?: string;      // 订阅转换器地址
    subConfig?: string;         // 订阅转换配置
    expiresAt?: string;
}
```

**功能**:
- **组合多个订阅源**：通过 `subscriptions` 数组引用多个 Subscription
- **添加手动节点**：通过 `manualNodes` 直接添加节点链接
- **自定义转换**：可以配置专属的转换器和配置文件

**存储位置**:
- 前端：`App.vue` 中的 `profiles` ref
- 后端：Cloudflare KV 存储，键名为 `KV_KEY_PROFILES` (sub_one_profiles_v1)

---

### 3. **节点 (Node)**
**定义位置**: `src/types.ts`

```typescript
export interface Node {
    id: string;
    name: string;
    url: string;            // 节点协议链接 (ss://, vmess://, etc.)
    protocol?: string;
    enabled: boolean;
    type?: string;
    subscriptionName?: string;
    originalProxy?: any;
}
```

**功能**:
- **代表单个代理节点**
- **由订阅解析器生成**：从订阅源内容解析出来

**来源**:
1. 从订阅URL获取的内容解析
2. 用户手动添加的节点链接
3. 订阅组中的手动节点

---

## 数据流向

### 📥 订阅数据获取流程

```
用户添加订阅
    ↓
保存到 KV (Subscription对象)
    ↓
前端调用 fetchNodeCount(subUrl)
    ↓
后端 /api/node_count 接口
    ↓
后端发起HTTP请求到订阅源
    ↓
获取订阅内容（Base64/YAML/等）
    ↓
SubscriptionParser.parse() 解析
    ↓
返回节点数组 (Node[])
    ↓
统计节点数量
    ↓
更新 Subscription.nodeCount
```

**关键文件**:
- API: `src/lib/api.ts` → `fetchNodeCount()`
- 后端: `functions/[[path]].ts` → `/api/node_count` 处理器
- 解析器: `src/lib/subscription-parser.ts` → `SubscriptionParser` 类

---

### 📤 订阅链接生成流程

#### A. **默认订阅链接** (全部启用的订阅)

```
用户选择"默认订阅"
    ↓
生成链接: /{mytoken}?target={format}
    ↓
客户端访问该链接
    ↓
后端 handleSubRequest()
    ↓
读取所有 enabled 的 Subscriptions
    ↓
对每个订阅URL发起HTTP请求
    ↓
使用 SubscriptionParser 解析内容
    ↓
应用 exclude 规则过滤节点
    ↓
应用 prependSubName 添加前缀
    ↓
合并所有节点链接
    ↓
根据 target 参数转换格式
    ↓
返回给客户端
```

**生成链接示例**:
- Base64: `https://example.com/mytoken123?target=base64`
- Clash: `https://example.com/mytoken123?target=clash`

---

#### B. **订阅组链接** (自定义组合)

```
用户选择某个订阅组
    ↓
生成链接: /{profileToken}/{profileId}?target={format}
    ↓
客户端访问该链接
    ↓
后端 handleSubRequest()
    ↓
根据 profileId 查找对应的 Profile
    ↓
获取 Profile.subscriptions（订阅ID列表）
    ↓
获取 Profile.manualNodes（手动节点）
    ↓
对每个订阅ID查找对应的 Subscription
    ↓
只处理 enabled 的订阅
    ↓
对每个订阅URL发起HTTP请求
    ↓
使用 SubscriptionParser 解析内容
    ↓
应用 Profile.subConfig 和 subConverter
    ↓
合并订阅节点 + 手动节点
    ↓
根据 target 参数转换格式
    ↓
返回给客户端
```

**生成链接示例**:
- `https://example.com/profileToken456/custom-profile-id?target=clash`

---

## 节点信息的多个"来源"

### 🎯 这是造成混乱的核心原因！

#### 1. **订阅管理的节点信息** (`Subscription.nodeCount`)
- **用途**: 显示在前端订阅卡片上，告诉用户这个订阅源有多少个节点
- **更新时机**: 
  - 添加订阅时
  - 手动点击"更新"按钮
  - 定时任务自动更新 (Cron)
- **数据来源**: 调用 `/api/node_count` 接口，后端抓取并解析订阅源
- **存储位置**: KV 存储中的 Subscription 对象
- **前端组件**: `SubscriptionCard.vue` 显示

#### 2. **订阅组的节点信息** (动态计算)
- **用途**: 订阅组不直接存储节点数量，而是引用多个订阅
- **计算方式**: 
  ```javascript
  // 伪代码
  profile.nodeCount = profile.subscriptions
    .map(subId => findSubscription(subId))
    .filter(sub => sub.enabled)
    .reduce((sum, sub) => sum + (sub.nodeCount || 0), 0)
    + profile.manualNodes.length
  ```
- **显示位置**: `ProfileCard.vue`

#### 3. **链接生成时的实时解析**
- **用途**: 当客户端访问订阅链接时，实时从订阅源获取最新节点
- **特点**: 
  - **不依赖** `Subscription.nodeCount`
  - 每次访问都重新抓取和解析
  - 应用最新的过滤规则
- **处理位置**: `functions/[[path]].ts` → `handleSubRequest()` → `generateCombinedNodeList()`

#### 4. **前端预览的节点列表**
- **用途**: 用户点击"预览"按钮时显示节点详情
- **实现**: `NodeDetailsModal.vue` 
- **数据获取**: 发起HTTP请求到生成的链接（强制使用 `target=base64`）
- **解析**: 前端使用 `subscription-parser.ts` 解析返回的内容

---

## 链接生成流程

### 前端部分 (`SubscriptionLinkGeneratorCard.vue`)

```javascript
// 1. 用户选择订阅类型
selectedId = 'default'  // 或 profile.customId

// 2. 确定使用的 Token
if (selectedId === 'default') {
  token = config.mytoken
} else {
  token = config.profileToken
}

// 3. 构建基础 URL
baseUrl = selectedId === 'default' 
  ? `${origin}/${token}` 
  : `${origin}/${token}/${selectedId}`

// 4. 添加格式参数
if (format !== '自适应') {
  finalUrl = `${baseUrl}?target=${formatParam}`
}
```

### 后端部分 (`functions/[[path]].ts`)

```javascript
// 1. 解析 URL 路径
// /{token} → 默认订阅
// /{token}/{profileId} → 订阅组

// 2. 验证 Token
if (isDefaultSub) {
  validateToken(token, settings.mytoken)
} else {
  validateToken(token, settings.profileToken)
}

// 3. 获取订阅列表
if (isDefaultSub) {
  subs = allSubscriptions.filter(s => s.enabled)
} else {
  profile = findProfile(profileId)
  subs = profile.subscriptions
    .map(id => findSubscription(id))
    .filter(s => s.enabled)
}

// 4. 获取节点内容
nodes = await Promise.all(
  subs.map(async sub => {
    content = await fetch(sub.url)
    nodes = SubscriptionParser.parse(content, sub.name)
    return SubscriptionParser.processNodes(nodes, sub.name, {
      exclude: sub.exclude,
      prependSubName: settings.prependSubName
    })
  })
)

// 5. 合并节点
allNodes = [...httpSubNodes, ...manualNodes]
uniqueNodes = [...new Set(allNodes)]

// 6. 格式转换
if (target === 'clash' || target === 'singbox') {
  // 调用订阅转换器
  convertedContent = await fetch(subConverter, {
    body: { nodes, config }
  })
} else {
  // 返回 Base64 编码的节点列表
  content = btoa(uniqueNodes.join('\n'))
}
```

---

## 常见问题和混淆点

### ❓ 问题 1: 订阅管理显示的节点数 ≠ 生成链接的实际节点数

**原因**: 
- `Subscription.nodeCount` 是**缓存值**，可能不是最新的
- 链接生成时是**实时抓取**，获取的是当前最新状态
- 过滤规则 (`exclude`) 只在链接生成时应用

**示例**:
```
订阅卡片显示: 96 个节点 (缓存的旧值)
实际订阅源: 9 个节点 (最新状态)
生成链接获取: 9 个节点 (实时)
```

**解决方案**:
- 确保更新订阅后同步更新 `nodeCount`
- 或者移除 `nodeCount` 显示，改为"点击更新查看"

---

### ❓ 问题 2: 订阅组的节点数不准确

**原因**:
- 订阅组的节点数是**累加计算**的
- 如果引用的订阅的 `nodeCount` 不准确，那么订阅组的统计也会错误

**解决方案**:
```javascript
// ProfileCard.vue 中应该这样计算
const totalNodes = computed(() => {
  let count = profile.manualNodes?.length || 0;
  
  profile.subscriptions?.forEach(subId => {
    const sub = subscriptions.find(s => s.id === subId);
    if (sub && sub.enabled) {
      count += sub.nodeCount || 0;
    }
  });
  
  return count;
});
```

---

### ❓ 问题 3: 前后端解析不一致

**表现**:
- 后端生成的节点格式与前端解析的不匹配
- 某些协议在前端能识别，后端不能，反之亦然

**原因**:
- 前端: `src/lib/subscription-parser.ts`
- 后端: `functions/[[path]].ts` 中的 `SubscriptionParser` 类
- **这是两个独立的解析器实现！**

**对比**:
| 特性 | 前端解析器 | 后端解析器 |
|------|-----------|-----------|
| 用途 | 预览、显示 | 生成订阅链接 |
| 运行环境 | 浏览器 | Cloudflare Worker |
| 依赖 | js-yaml | js-yaml |
| 协议支持 | 相同但实现可能不同 | 相同但实现可能不同 |

**解决方案**:
- 统一两个解析器的实现
- 或者将解析器代码提取到 `shared/` 目录共享

---

### ❓ 问题 4: `exclude` 规则在哪里应用？

**答案**: **只在链接生成时应用**

```javascript
// 前端显示的 nodeCount: 不过滤
Subscription.nodeCount = 96  // 原始数量

// 链接生成时: 应用过滤
SubscriptionParser.processNodes(nodes, subName, {
  exclude: sub.exclude  // 这里应用过滤规则
})
// 最终返回的节点可能只有 9 个
```

**这意味着**:
- 订阅卡片显示的数量是**过滤前**的
- 实际链接返回的节点是**过滤后**的

**建议**:
- 在订阅卡片上添加标识，说明"已配置过滤规则"
- 或者在更新 `nodeCount` 时就应用过滤

---

## 建议的改进方向

### 1. **统一解析器**
将前后端的 `SubscriptionParser` 合并为一个模块：

```
shared/
  └── subscription-parser.ts  (共享的解析器)

前端和后端都 import 这个文件
```

### 2. **明确节点计数的含义**
在 Subscription 类型中添加两个字段：

```typescript
export interface Subscription {
  // ...
  rawNodeCount?: number;      // 原始节点数（过滤前）
  filteredNodeCount?: number; // 过滤后的节点数
}
```

### 3. **实时计算 vs 缓存**
明确区分：
- **缓存值**: 用于快速显示，定期更新
- **实时值**: 用于链接生成，每次请求时获取

### 4. **添加调试信息**
在开发模式下显示：
```
订阅: 我的订阅
├─ 缓存节点数: 96 (更新于 2小时前)
├─ 排除规则: 香港|日本
└─ 预计过滤后: ~15 个节点
```

### 5. **数据流向可视化**
在前端添加一个"调试面板"：

```
[订阅源] → [解析器] → [过滤器] → [转换器] → [生成链接]
   ↓          ↓          ↓           ↓           ↓
 HTTP获取   识别协议   应用规则   Base64/YAML  最终URL
```

### 6. **错误边界处理**
添加更详细的错误信息：

```javascript
try {
  nodes = await fetchAndParse(subUrl);
} catch (error) {
  return {
    success: false,
    error: '解析失败',
    details: {
      url: subUrl,
      stage: 'parsing',  // 'fetching' | 'parsing' | 'filtering'
      message: error.message
    }
  };
}
```

---

## 总结

### 核心关系图

```
┌─────────────────────────────────────────────────────────┐
│                     用户界面                              │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  订阅管理                         订阅组管理              │
│  ┌─────────────┐                 ┌─────────────┐       │
│  │ Subscription│                 │   Profile   │       │
│  │  - nodeCount│◄────────────────│- subs[]     │       │
│  │  - url      │                 │- manualNodes│       │
│  │  - exclude  │                 │             │       │
│  └─────────────┘                 └─────────────┘       │
│         │                               │               │
│         └───────────────┬───────────────┘               │
│                         ▼                               │
│              ┌─────────────────────┐                    │
│              │  链接生成器          │                    │
│              │  - 选择订阅/组       │                    │
│              │  - 选择格式          │                    │
│              │  - 生成URL           │                    │
│              └─────────────────────┘                    │
│                         │                               │
└─────────────────────────┼───────────────────────────────┘
                          ▼
              ┌─────────────────────┐
              │   后端处理           │
              ├─────────────────────┤
              │ 1. 验证Token         │
              │ 2. 获取订阅列表      │
              │ 3. 抓取订阅内容      │
              │ 4. 解析节点          │
              │ 5. 应用过滤规则      │
              │ 6. 格式转换          │
              │ 7. 返回结果          │
              └─────────────────────┘
                          │
                          ▼
                   客户端获取订阅
```

### 关键要点

1. **Subscription**: 基础单元，存储订阅源URL和元数据
2. **Profile**: 组合单元，引用多个 Subscription + 手动节点
3. **Node**: 运行时单元，从订阅源解析出来的实际节点
4. **nodeCount**: 缓存值，不代表链接生成时的实际节点数
5. **链接生成**: 实时过程，每次都重新抓取和解析
6. **前后端解析器**: 两个独立实现，需要保持一致

---

## 调试建议

当遇到 bug 时，按照以下顺序排查：

1. ✅ **确认数据源**: 订阅URL是否可访问？返回内容格式是什么？
2. ✅ **检查解析器**: 前端和后端的解析器是否都能正确识别该格式？
3. ✅ **验证过滤规则**: `exclude` 规则是否正确应用？
4. ✅ **追踪数据流**: 从 Subscription → Profile → 链接生成，每一步的数据是什么？
5. ✅ **对比前后端**: 前端显示的节点数 vs 后端生成的实际节点数

**日志关键点**:
```javascript
console.log('1. 订阅源URL:', sub.url);
console.log('2. 抓取的原始内容:', rawContent);
console.log('3. 解析出的节点:', parsedNodes);
console.log('4. 应用过滤后:', filteredNodes);
console.log('5. 最终返回:', finalContent);
```

---

希望这份文档能帮助你理清订阅系统的架构！如有疑问，随时提问。
